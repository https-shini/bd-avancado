-- =====================================================================
-- PARTE 1: CRIAÇÃO DAS TABELAS (ESTUDO DE CASO: CLÍNICA MÉDICA)
-- Definição da estrutura do banco de dados para o agendamento de consultas.
-- =====================================================================

-- Tabela para armazenar as especialidades dos médicos.
CREATE TABLE tbEspecialidade(
    idEspecialidade NUMBER PRIMARY KEY,
    especialidade VARCHAR2(40),
    -- Coluna para "soft delete": 0 = ativo, 1 = inativo. Preserva o histórico.
    deleted NUMBER(1) DEFAULT 0,
    -- Colunas de auditoria: registram a data de criação e da última alteração.
    data_criacao DATE DEFAULT sysdate,
    data_alteracao DATE DEFAULT sysdate
);

-- Tabela para armazenar os dados dos médicos.
CREATE TABLE tbMedico(
    idMedico NUMBER PRIMARY KEY,
    nomeMedico VARCHAR2(40),
    crmMedico VARCHAR(40),
    idEspecialidade NUMBER,
    deleted NUMBER(1) DEFAULT 0,
    data_criacao DATE DEFAULT sysdate,
    data_alteracao DATE DEFAULT sysdate,
    -- Chave estrangeira que conecta o médico à sua especialidade.
    FOREIGN KEY (idEspecialidade) REFERENCES tbEspecialidade(idEspecialidade)
);

-- Tabela para armazenar os dados dos pacientes.
CREATE TABLE tbPaciente(
    idPaciente NUMBER PRIMARY KEY,
    nomePaciente VARCHAR2(40),
    emailPaciente VARCHAR2(40),
    cpfPaciente VARCHAR2(14),
    deleted NUMBER(1) DEFAULT 0,
    data_criacao DATE DEFAULT sysdate,
    data_alteracao DATE DEFAULT sysdate
);

-- Tabela principal que registra os agendamentos das consultas.
CREATE TABLE tbAgendaConsulta(
    idAgendaConsulta NUMBER PRIMARY KEY,
    idPaciente NUMBER,
    idMedico NUMBER,
    dataConsulta DATE,
    horaConsulta TIMESTAMP,
    deleted NUMBER(1) DEFAULT 0,
    data_criacao DATE DEFAULT sysdate,
    data_alteracao DATE DEFAULT sysdate,
    -- Chaves estrangeiras que conectam a consulta ao paciente e ao médico.
    FOREIGN KEY (idPaciente) REFERENCES tbPaciente(idPaciente),
    FOREIGN KEY (idMedico) REFERENCES tbMedico(idMedico)
);


-- =====================================================================
-- PARTE 2: INSERÇÃO DE DADOS INICIAIS
-- Populando as tabelas com dados de exemplo para os exercícios.
-- =====================================================================

-- Inserindo especialidades
INSERT INTO tbEspecialidade (idEspecialidade, especialidade) VALUES (1, 'Pediatria');
INSERT INTO tbEspecialidade (idEspecialidade, especialidade) VALUES (2, 'Cardiologia');
INSERT INTO tbEspecialidade (idEspecialidade, especialidade) VALUES (3, 'Ortopedia');

-- Inserindo médicos
INSERT INTO tbMedico (idMedico, nomeMedico, crmMedico, idEspecialidade) VALUES (1, 'Dr. Moacir', '11111', 1);
INSERT INTO tbMedico (idMedico, nomeMedico, crmMedico, idEspecialidade) VALUES (2, 'Dra. Ana', '22222', 2);
INSERT INTO tbMedico (idMedico, nomeMedico, crmMedico, idEspecialidade) VALUES (3, 'Dr. Carlos', '33333', 3);


-- Inserindo pacientes
INSERT INTO tbPaciente (idPaciente, nomePaciente, emailPaciente, cpfPaciente) VALUES (1, 'Gabriela', 'gabriela@gmail.com', '111.111.111-11');
INSERT INTO tbPaciente (idPaciente, nomePaciente, emailPaciente, cpfPaciente) VALUES (2, 'Felipe', 'felipe@gmail.com', '222.222.222-22');
INSERT INTO tbPaciente (idPaciente, nomePaciente, emailPaciente, cpfPaciente, deleted) VALUES (3, 'Mariana (Inativa)', 'mariana@gmail.com', '333.333.333-33', 1);


-- Inserindo agendamentos de consulta
-- Consulta futura (manhã)
INSERT INTO tbAgendaConsulta (idAgendaConsulta, idPaciente, idMedico, dataConsulta, horaConsulta)
VALUES (1, 1, 1, TO_DATE('2025-09-15','yyyy-mm-dd'), TO_TIMESTAMP('10:00:00', 'hh24:mi:ss'));
-- Consulta futura (tarde)
INSERT INTO tbAgendaConsulta (idAgendaConsulta, idPaciente, idMedico, dataConsulta, horaConsulta)
VALUES (2, 2, 2, TO_DATE('2025-09-20','yyyy-mm-dd'), TO_TIMESTAMP('15:30:00', 'hh24:mi:ss'));
-- Consulta passada
INSERT INTO tbAgendaConsulta (idAgendaConsulta, idPaciente, idMedico, dataConsulta, horaConsulta)
VALUES (3, 1, 3, TO_DATE('2024-08-10','yyyy-mm-dd'), TO_TIMESTAMP('09:00:00', 'hh24:mi:ss'));
-- Consulta para hoje (manhã)
INSERT INTO tbAgendaConsulta (idAgendaConsulta, idPaciente, idMedico, dataConsulta, horaConsulta)
VALUES (4, 2, 1, TRUNC(SYSDATE), TO_TIMESTAMP('08:30:00', 'hh24:mi:ss'));


-- =====================================================================
-- PARTE 3: EXERCÍCIOS DE VIEWS (RESOLVIDOS)
-- Criação das Views solicitadas na Aula 04.
-- =====================================================================

-- 1. Crie e execute uma view que mostre o nome do médico, o crm e a especialidade.
CREATE OR REPLACE VIEW vw_medico_especialidade AS
SELECT
    m.nomeMedico AS nome_medico,
    m.crmMedico AS crm,
    e.especialidade
FROM
    tbMedico m
INNER JOIN
    tbEspecialidade e ON m.idEspecialidade = e.idEspecialidade;

-- 2. Crie e execute uma view que mostre o nome do paciente, o nome do médico, a especialidade do médico, e a data e hora da consulta.
CREATE OR REPLACE VIEW vw_consulta_paciente AS
SELECT
    p.nomePaciente AS nome_paciente,
    m.nomeMedico AS nome_medico,
    e.especialidade,
    a.dataConsulta AS data_da_consulta,
    a.horaConsulta AS hora_da_consulta
FROM
    tbAgendaConsulta a
INNER JOIN
    tbPaciente p ON a.idPaciente = p.idPaciente
INNER JOIN
    tbMedico m ON a.idMedico = m.idMedico
INNER JOIN
    tbEspecialidade e ON m.idEspecialidade = e.idEspecialidade;

-- 3. Crie e execute uma view que mostre somente os pacientes que não foram "excluídos".
CREATE OR REPLACE VIEW vw_pacientes_ativos AS
SELECT
    idPaciente,
    nomePaciente,
    emailPaciente,
    cpfPaciente
FROM
    tbPaciente
WHERE
    deleted = 0;

-- 4. Crie e execute uma view que traga apenas consultas cuja data seja maior que o dia atual.
CREATE OR REPLACE VIEW vw_consultas_futuras AS
SELECT
    idAgendaConsulta,
    idPaciente,
    idMedico,
    dataConsulta,
    horaConsulta
FROM
    tbAgendaConsulta
WHERE
    dataConsulta > TRUNC(SYSDATE);

-- 5. Crie e execute uma view que exiba o total de pacientes cadastrados.
CREATE OR REPLACE VIEW vw_quantidade_pacientes AS
SELECT
    COUNT(idPaciente) AS total_de_pacientes
FROM
    tbPaciente;

-- 6. Crie e execute uma view que exiba apenas as consultas agendadas na data atual no período entre 8h e 12h.
CREATE OR REPLACE VIEW vw_consultas_manha AS
SELECT
    idAgendaConsulta,
    idPaciente,
    idMedico,
    dataConsulta,
    horaConsulta
FROM
    tbAgendaConsulta
WHERE
    dataConsulta = TRUNC(SYSDATE)
    AND TO_CHAR(horaConsulta, 'HH24') >= '08'
    AND TO_CHAR(horaConsulta, 'HH24') < '12';

-- =====================================================================
-- PARTE 4: EXECUÇÃO E TESTE DAS VIEWS
-- Comandos para visualizar os resultados das Views criadas.
-- =====================================================================

-- Testando a View 1
SELECT * FROM vw_medico_especialidade;

-- Testando a View 2
SELECT * FROM vw_consulta_paciente;

-- Testando a View 3
SELECT * FROM vw_pacientes_ativos;

-- Testando a View 4
SELECT * FROM vw_consultas_futuras;

-- Testando a View 5
SELECT * FROM vw_quantidade_pacientes;

-- Testando a View 6
SELECT * FROM vw_consultas_manha;

-- =====================================================================
-- PARTE 1: EXCLUSÃO DAS VIEWS (AULA 04)
-- É uma boa prática remover as views antes de remover as tabelas
-- das quais elas dependem.
-- =====================================================================

DROP VIEW vw_medico_especialidade;
DROP VIEW vw_consulta_paciente;
DROP VIEW vw_pacientes_ativos;
DROP VIEW vw_consultas_futuras;
DROP VIEW vw_quantidade_pacientes;
DROP VIEW vw_consultas_manha;


-- =====================================================================
-- PARTE 2: EXCLUSÃO DAS TABELAS DA CLÍNICA MÉDICA (AULA 04)
-- As tabelas devem ser removidas na ordem inversa de sua criação
-- para evitar erros de restrição de chave estrangeira (foreign key).
-- =====================================================================

-- 1. Remove a tabela de agendamentos, que depende de Paciente e Medico.
DROP TABLE tbAgendaConsulta;

-- 2. Remove a tabela de médicos, que depende de Especialidade.
DROP TABLE tbMedico;

-- 3. Remove a tabela de pacientes.
DROP TABLE tbPaciente;

-- 4. Remove a tabela de especialidades.
DROP TABLE tbEspecialidade;


-- =====================================================================
-- PARTE 3: EXCLUSÃO DAS TABELAS DO PORTAL DE NOTÍCIAS (AULAS 01-03)
-- Seguindo a mesma lógica, remove as tabelas na ordem inversa
-- para respeitar as dependências.
-- =====================================================================

-- 1. Remove a tabela associativa, que depende de Notícia e Jornalista.
DROP TABLE tb_noticia_jornalista;

-- 2. Remove a tabela de notícias, que depende de Status e Categoria.
DROP TABLE tb_noticia;

-- 3. Remove a tabela de jornalistas.
DROP TABLE tb_jornalista;

-- 4. Remove a tabela de status.
DROP TABLE tb_status_noticia;

-- 5. Remove a tabela de categorias.
DROP TABLE tb_categoria;


-- =====================================================================
-- Aula 05 - PL/SQL 
-- PARTE 1: DBMS_OUTPUT e DBMS_OUTPUT
-- Introdução e comandos
-- =====================================================================

declare
	v_nome varchar2(40) := 'Bruna'
begin
	dbms_output.put_line('Olá mundo!');
	dbms_output.put_line('Seja bem-vindo' || v_nome);
end;

---

DECLARE
    numeroAleatorio NUMBER;
BEGIN
    numeroAleatorio := TRUNC(DBMS_RANDOM.VALUE(1,11));
	DBMS_OUTPUT.PUT_LINE('Número gerado: ' || numeroAleatorio);
END;


-- =====================================================================
-- AULA 05 - PARTE 5: EXERCÍCIOS DE PL/SQL (RESOLVIDOS)
-- Blocos de código para praticar a lógica procedural no Oracle.
-- =====================================================================

-- Executando Exercício 1 de PL/SQL (Média do Aluno)...
-- Bloco para calcular a média de um aluno e exibir sua situação.
DECLARE
  -- Definição das variáveis para as notas e a média.
  v_nota1 NUMBER := 6.5;
  v_nota2 NUMBER := 5.0;
  v_media NUMBER;
BEGIN
  -- Calcula a média das duas notas.
  v_media := (v_nota1 + v_nota2) / 2;

  -- Exibe a média calculada para o usuário.
  DBMS_OUTPUT.PUT_LINE('Média do aluno: ' || v_media);

  -- Utiliza a estrutura IF/ELSIF/ELSE para determinar a situação do aluno.
  IF v_media >= 6 THEN
    DBMS_OUTPUT.PUT_LINE('Situação: Aprovado');
  ELSIF v_media >= 4.01 AND v_media <= 5.99 THEN
    DBMS_OUTPUT.PUT_LINE('Situação: Exame');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Situação: Reprovado');
  END IF;
END;


-- Executando Exercício 2 de PL/SQL (Sorteio de Números)...
-- Bloco que simula um sorteio e compara com números escolhidos.
DECLARE
  -- Números que o "usuário" escolheu.
  v_num1_escolhido NUMBER := 2;
  v_num2_escolhido NUMBER := 4;
  v_num3_escolhido NUMBER := 6;

  -- Variáveis para guardar os números que serão sorteados.
  v_num1_sorteado NUMBER;
  v_num2_sorteado NUMBER;
  v_num3_sorteado NUMBER;
BEGIN
  -- Gera dois números aleatórios inteiros entre 1 e 10.
  -- DBMS_RANDOM.VALUE(min, max) gera um número decimal. A função TRUNC() o converte para inteiro.
  v_num1_sorteado := TRUNC(DBMS_RANDOM.VALUE(1, 11)); -- O limite superior (11) é exclusivo.
  v_num2_sorteado := TRUNC(DBMS_RANDOM.VALUE(1, 11));
  v_num3_sorteado := TRUNC(DBMS_RANDOM.VALUE(1, 11));

  -- Exibe os números para comparação.
  DBMS_OUTPUT.PUT_LINE('Números escolhidos: ' || v_num1_escolhido || ' e ' || v_num2_escolhido || ' e '  || v_num3_escolhido);
  DBMS_OUTPUT.PUT_LINE('Números sorteados: ' || v_num1_sorteado || ' e ' || v_num2_sorteado || ' e '  || v_num3_escolhido);


  -- Compara se AMBOS os números escolhidos são iguais aos sorteados.
  IF v_num1_escolhido = v_num1_sorteado AND v_num2_escolhido = v_num2_sorteado AND v_num3_escolhido = v_num3_sorteado THEN
    DBMS_OUTPUT.PUT_LINE('Resultado: Parabéns! Você acertou em cheio!');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Resultado: Não foi desta vez. Tente novamente!');
  END IF;
END;


-- Executando Exercício 3 de PL/SQL (Cálculo de Aumento Salarial)...
-- Bloco para calcular e exibir o reajuste de salário de um funcionário.
DECLARE
  -- Definição das variáveis de entrada.
  v_nome_funcionario   VARCHAR2(100) := 'Sabrina de Souza';
  v_salario_atual      NUMBER(10, 2) := 5000.00; -- Formato com 10 dígitos no total e 2 decimais.
  v_percentual_aumento NUMBER        := 10;      -- Aumento de 10%

  -- Variável para armazenar o resultado do cálculo.
  v_novo_salario       NUMBER(10, 2);
BEGIN
  -- A lógica de cálculo do novo salário.
  v_novo_salario := v_salario_atual + (v_salario_atual * (v_percentual_aumento / 100));

  -- Exibição formatada dos resultados para o usuário.
  DBMS_OUTPUT.PUT_LINE('--- Relatório de Reajuste Salarial ---');
  DBMS_OUTPUT.PUT_LINE('Funcionário: ' || v_nome_funcionario);
  DBMS_OUTPUT.PUT_LINE('Salário Atual: R$ ' || v_salario_atual);
  DBMS_OUTPUT.PUT_LINE('Novo Salário com ' || v_percentual_aumento || '% de aumento: R$ ' || v_novo_salario);
END;


